---
title: 线程池(一)
date: 2019-07-09 19:08:35
tags: ["android"]
categories: Android开发
---

## 线程
**进程**是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，一个进程中可以启动多个线程。比如在Windows系统中，一个运行的exe就是一个进程。一条**线程**指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

## 创建线程
* 通过实现 Runnable 接口；
创建一个线程，最简单的方法是创建一个实现 Runnable 接口的类，实现其run方法

* 通过继承 Thread 类本身
创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。

该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。
* 通过 Callable 和 Future 创建线程
 a. 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。
 b. 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。
 c. 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。
 d. 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。
<!--more-->

RunnableExample.kt
```Kotlin
package com.cool1024

class RunnableExample:Runnable{
    override fun run(){
        println("RunnableExample")
    }
}
```

ThreadExample.kt
```Kotlin
package com.cool1024

class ThreadExample:Thread(){
    override fun run(){
        println("ThreadExample")
    }
}
```

CallableExample.kt
```Kotlin
package com.cool1024

import java.util.concurrent.Callable

class CallableExample:Callable<Boolean>{
    override fun call():Boolean{
        println("CallableExample")
        return true
    }
}
```

App.kt
```Kotlin
package com.cool1024

import java.util.concurrent.FutureTask

object App{
    @JvmStatic
    fun main(args: Array<String>) {
        val runnableExample = Thread(RunnableExample())
        runnableExample.start()
        val threadExample = ThreadExample()
        threadExample.start()
        val callableExample = CallableExample()
        val futureTask = FutureTask<Boolean>(callableExample)
        Thread(futureTask).start()
        println("Return value${futureTask.get()}")
    }
}
```


